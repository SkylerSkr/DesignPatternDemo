单一职责原则 对于一个类而言,应该只有一个引起他变化的原因
开放封闭原则 是说软件实体(类,模块,函数等等)应该可以扩展,但是不可以修改
依赖倒转原则 A.高层模块不应该依赖底层模块。两个都应该依赖抽象。
	     B.抽象不应该依赖细节。细节应该依赖抽象。
里斯转换原则 子类型必须能够替换掉他们的父类型。
迪米特原则 如果两个类不必彼此直接通讯,那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用。
合成复用原则 尽量使用合成/聚合(组合,聚合),尽量不使用类继承 继承是强耦合的关系 用组合可以避免增长成不可控制的庞然大物

1.简单工厂模式
是最简单的设计模式
工厂类根据客户需要生成对应的对象
更加易于维护，扩展，复用

2.策略模式
定义了算法家族,分别封装起来,让他们之间可以相互替换,让算法的变换不会影响到使用算法的客户
用来封装算法 客户端不需要知道怎么处理的
可以简化单元测试 对每种算法单独测试

3.装饰模式
动态的给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成子类更灵活。
为已有功能动态的添加更多的功能的一种模式
这些新添加的功能装饰了原有的核心的功能
当需要执行特殊行为的时候就可以使用装饰模式
把核心功能和装饰功能区分开

4.代理模式
为其他对象提供一种代理以控制对这个对象的访问
远程代理 为一个对象在不同的地址空间提供局部地址 隐藏一个对象存在不同地址空间的事实
虚拟代理 存放实例化开销很大的真是对象
安全代理 控制真实对象的访问权限

5.工厂方法模式
定义一个对于创建对象的接口,让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类
简单工厂的升级版 更加贴近开放闭合原则
为每一个子类写一个工厂类

6.原型模式
用原型模式指定创建对象的种类,并且通过拷贝这些原型来创建新的对象
浅度复制 深度复制
是想ICloneable接口 然后重写Clone方法 (Object)this.MemberwiseClone();
深度复制有Copy不仅复制结构还复制数据

7.模板方法模型
定义一个操作中算法的骨架,而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可改变算法的某些特定步骤
把不变的行为移动到超类里面,去除子类里的重复代码
可以说是靠父类方法调用自己的方法

8.外观模式
为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更加容易使用。
给旧系统一个外观 提供接口给新系统用Facade

9.建造者模式
将一个复杂的对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示
用建造者模式,用户只需要指定建造的类型就可以得到它们,具体建造的细节就不需要知道了

10.观察者模式
观察者模式定义了一种一对多的依赖关系,让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时,会通知所有的观察者对象,使它们能够自动的更新自己
在.net里面有委托这个概念
delegata void EventHandler();//定义一个事件处理程序
public event EventHandler eventHandler;//定义一个委托  就是可以传递的方法
委托对象所搭载的所有方法必须具有相同的原型和形式,也就是拥有相同的参数列表和返回值
当对象相互依赖的时候可以用


11.抽象工厂模式
提供一系列相互依赖对象的接口,而无需指定它们具体的类。
更加复合依赖倒转原则,开放封闭原则
工厂方法模型的升级版 当工厂不止生产一种产品的时候
但是会扩展起来很麻烦 可以用反射简化
using System.Reflection;

(Object)Assembly.Load(string 程序集).CreateInstance(string 命名空间.类名);
就是可以根据类名创建对象 字符串

12.状态模式
当一个对象的内在状态改变时允许改变其行为,这个对象看上去像改变了其类。
把各个状态对应的行为都写一个单独的类 类里判断是否时这个状态 如果不是就把该类指向下一个状态
每一个状态都排好顺序
不用写很多的swith ifelse 语句 

13.适配器模式
将一个类的接口改变成客户希望的另外一个接口
用于更改已经有的类 弥补程序设计的失误
包含需要具体操作的类

14.备忘录模式
在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态,这样之后就可将该状态恢复到原来保存的状态
适合比较功能比较复杂,但需要维护或者记录属性历史的类，或需要保存部分属性的类
或者对象属性即将暂时改变的时候

15.组合模式
将对象组成的树型结构以表示 部分-整体 的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性
安全模式 把单个对象不要的方法不要写进父类
透明模式 让单个对象和组合对象具有相同的接口
希望忽略单个对象和组合对象的区别 可以统一使用的时候使用

16.迭代器模式
提供一种方法顺序访问一个聚合对象中各个元素,而不是暴露该对象的内部表示
c#里时foreach 实现了Iterator和IEumerator接口

17.单例模式
保证一个类仅有一个实例,并提供一个访问它的全局访问点
把构造方法私有化 并在类里面包含一个该类实例化的字段
锁 lock（Object o）{}安全性
静态初始化 占内存
public sealed class singleton 阻止发生派生 就是不让创建对象
private static readonly Singleton instance=new Singleton();
普通的 需要加lock防止多线程里生成多个对象

18.桥接模式
将抽象部分和它的具体实现部分分离,使他们都可以独立的变化
实现系统可能有多种分类的可能,没一种分类都可能变化,那么就把多种角度分离出来让他们独立变化,减少他们之间的耦合

19.命令模式
将一个请求封装成一个对象,从而使你可用不同的请求对客户进行参数化,对请求排队或记录请求日志,以及支持可撤销的操作
命令类包含执行者 命令管理者收集命令并指挥执行者 使请求者和执行者相互不认识 迪米塔原则
不为代码增加猜测会需要的功能

20.职责链模式
使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系,将这个对象连成一条链，并沿着这条链传递该请求,直到有一个对象处理该请求
和状态模式很像
状态模式：需要先定义好状态的顺序(在类里面),如果处理不了就重新给状态赋值,再执行对象的处理方法
职责链模式：可以按需求在客户端定义顺序,但是设置每一个对象的下一个对象使什么。如果处理不了就运行下一个的对象的处理方法。

21.中介者模式
对象之间的相互连接会降低复用性
用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示的相互引用,从而使其耦合松散,而且可以独立的改变它们之间的交互。
迪米特原则：如果两个没有相互包含的必要,就找一个第三方包含这两个对象
中介者需要包含要协调的所有对象,需要被协调的对象要认识中介者
但是中介者类责任会非常的重,一般用于一组对象以定义良好但是以复杂的方式进行通信的场合

22.享元模式
运用共享技术有效的地支持大量细颗粒的对象
享元模式可以避免大量相似实例的开销。当大量实例里除了少数几个属性之外都相同,可以把者几个属性放到外面去，然后共享实例
类里提供use方法 这个方法传递不一样的属性 工厂里判断是否包含

23.解释器模式
给定一个语言,定义其语法的一种表示,并定义一个解释器，用来翻译语句
如果一种问题发生的频率高 就把他弄成语句分析
正则表达式

24.访问者模式
表示一个作用于某对象(访问者)结构中的各元素的操作。它使你可以在不改变各元素的类的情况下定义对于这些元素的新操作
在被访问的对象数量是固定的不会改变的时候,在访问者里定义访问了每一个元素的操作
一般不存在固定不变的元素,所以很少使用
把访问者当形式参数传给元素 然后元素的内部把自己传给访问者 访问是再访问者里执行的


创建型模式:单例模式,工厂方法模式,抽象工厂模式,建造者模式,原型模式
结构型模式:适配器模式,装饰模式,桥接模式,组合模式,享元模式,代理模式,外观模式
行为型模式：观察者模式,模板方法模式,命令模式,状态模式,职责链模式
	    解释器模式,中介者模式,访问者模式,策略模式,备忘录模式,迭代器模式
常用的模式:工厂方法模式,外观模式,观察者模式(委托),策略模式,适配器模式
外观模式:在业务逻辑和表示层间增加业务外观层,这样不管是bs还是cs都不会影响到业务和数据的统计
观察者模式:按钮点击,事件驱动
适配器模式:有些功能是第三方软件,购买来的,用来适配
策略模式:把统计业务可以需要的算法封装起来
工厂方法模式:对象管理者,优先使用工厂方法,如果发现需要再考虑抽象工厂、反射技术等